<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hardware Interface | Reece Holland</title><meta name=keywords content><meta name=description content="Developing a Custom ROS 2 Hardware Interface for the Rugged Rover

Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we&rsquo;re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.

Hardware Interface with ros2_control
The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: rugged_rover_hardware_interfaces, following the ros2_control system interface pattern."><meta name=author content><link rel=canonical href=https://reeceholland.github.io/posts/hardware-interface/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://reeceholland.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reeceholland.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reeceholland.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reeceholland.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reeceholland.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reeceholland.github.io/posts/hardware-interface/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://reeceholland.github.io/posts/hardware-interface/"><meta property="og:site_name" content="Reece Holland"><meta property="og:title" content="Hardware Interface"><meta property="og:description" content="Developing a Custom ROS 2 Hardware Interface for the Rugged Rover Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we’re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.
Hardware Interface with ros2_control The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: rugged_rover_hardware_interfaces, following the ros2_control system interface pattern."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-24T05:52:43+08:00"><meta property="article:modified_time" content="2025-07-24T05:52:43+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hardware Interface"><meta name=twitter:description content="Developing a Custom ROS 2 Hardware Interface for the Rugged Rover

Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we&rsquo;re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.

Hardware Interface with ros2_control
The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: rugged_rover_hardware_interfaces, following the ros2_control system interface pattern."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reeceholland.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Hardware Interface","item":"https://reeceholland.github.io/posts/hardware-interface/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hardware Interface","name":"Hardware Interface","description":"Developing a Custom ROS 2 Hardware Interface for the Rugged Rover Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we\u0026rsquo;re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.\nHardware Interface with ros2_control The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: rugged_rover_hardware_interfaces, following the ros2_control system interface pattern.\n","keywords":[],"articleBody":"Developing a Custom ROS 2 Hardware Interface for the Rugged Rover Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we’re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.\nHardware Interface with ros2_control The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: rugged_rover_hardware_interfaces, following the ros2_control system interface pattern.\nThe SabertoothSystemInterface:\nExports position and velocity state interfaces for the left and right wheel joints. Publishes battery voltage as an additional StateInterface. Publishes joint velocity commands via sensor_msgs/JointState. Subscribes to custom feedback messages (rugged_rover_interfaces/msg/RoverFeedback) coming from the Arduino/Teensy, which includes encoder-based position, velocity, and battery voltage. The interface is fully wired into the ROS 2 control loop and integrates cleanly with controller_manager and joint_state_broadcaster.\nMicrocontroller Upgrade: From Arduino Mega to Teensy 4.1 During initial development, I used an Arduino Mega to read encoders, perform PID calculations, and communicate with ROS via serial. While the Mega worked well for prototyping, several limitations started to bottleneck development:\nLimited clock speed (16 MHz) made it hard to handle high-frequency PID control and multi-tasking serial communications. Large physical footprint made internal mounting in the chassis more difficult. Lack of native USB high-speed and modern architecture led to sporadic delays under load. The Decision: Teensy 4.1 To solve these issues, I’ve decided to move forward with a Teensy 4.1:\n600 MHz ARM Cortex-M7 processor with 1 MB RAM gives us ample performance headroom. Compact form factor reduces space requirements in the electronics enclosure. Native USB High-Speed (480 Mbps) provides snappy ROS serial integration. Multiple hardware serial ports (up to 8!) simplifies wiring and expands options for future peripherals (e.g., GPS, IMU). The upgrade will also enable smoother encoder sampling, non-blocking communication, and support for real-time motor control tasks on a single MCU.\nPID Tuning Challenges One of the more stubborn problems has been tuning the wheel speed PID controllers.\nWith simulated data or slow commands, everything behaves predictably. Under real load, slight mismatches in encoder readings or noisy sampling can cause aggressive oscillations or sluggish response. Integral windup occasionally causes the rover to overshoot or lock into runaway output when reversing direction. Next steps include:\nImplementing anti-windup in the PID logic. Adding low-pass filtering to the encoder velocity signal. Dynamically scaling PID gains based on load or command profile. Profiling CPU usage and ensuring sampling intervals remain consistent (especially after switching to Teensy). What’s Next Finalize wiring for the Teensy 4.1 and update the firmware to support its serial and interrupt pin layout. Connect ROS 2 controllers (like diff_drive_controller) and test real-world trajectory tracking. Improve unit testing for the hardware interface and expand test coverage for safety-critical paths. Explore publishing diagnostics like battery voltage, current draw, and motor temperature for system health monitoring. Stay tuned for future posts as I bring the full stack online—from URDF and Gazebo simulation to autonomous waypoint navigation and mission execution.\n","wordCount":"518","inLanguage":"en","datePublished":"2025-07-24T05:52:43+08:00","dateModified":"2025-07-24T05:52:43+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://reeceholland.github.io/posts/hardware-interface/"},"publisher":{"@type":"Organization","name":"Reece Holland","logo":{"@type":"ImageObject","url":"https://reeceholland.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reeceholland.github.io/ accesskey=h title="Reece Holland (Alt + H)">Reece Holland</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reeceholland.github.io/about/ title=About><span>About</span></a></li><li><a href=https://reeceholland.github.io/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Hardware Interface</h1><div class=post-meta><span title='2025-07-24 05:52:43 +0800 +0800'>July 24, 2025</span></div></header><div class=post-content><h1 id=developing-a-custom-ros-2-hardware-interface-for-the-rugged-rover>Developing a Custom ROS 2 Hardware Interface for the Rugged Rover<a hidden class=anchor aria-hidden=true href=#developing-a-custom-ros-2-hardware-interface-for-the-rugged-rover>#</a></h1><hr><p>Over the past few weeks, I’ve been working on integrating a custom hardware interface for the rugged wheeled rover platform we&rsquo;re building. This post highlights the development process of the ROS 2 hardware interface, the decision to upgrade to a Teensy 4.1 microcontroller, and the ongoing challenges with PID tuning.</p><hr><h2 id=hardware-interface-with-ros2_control>Hardware Interface with <code>ros2_control</code><a hidden class=anchor aria-hidden=true href=#hardware-interface-with-ros2_control>#</a></h2><p>The robot uses a differential drive setup controlled via a Sabertooth 2x12 motor driver. To interface this with ROS 2, I created a custom package: <code>rugged_rover_hardware_interfaces</code>, following the <code>ros2_control</code> system interface pattern.</p><p>The <code>SabertoothSystemInterface</code>:</p><ul><li>Exports position and velocity state interfaces for the left and right wheel joints.</li><li>Publishes battery voltage as an additional <code>StateInterface</code>.</li><li>Publishes joint velocity commands via <code>sensor_msgs/JointState</code>.</li><li>Subscribes to custom feedback messages (<code>rugged_rover_interfaces/msg/RoverFeedback</code>) coming from the Arduino/Teensy, which includes encoder-based position, velocity, and battery voltage.</li></ul><p>The interface is fully wired into the ROS 2 control loop and integrates cleanly with <code>controller_manager</code> and <code>joint_state_broadcaster</code>.</p><hr><h2 id=microcontroller-upgrade-from-arduino-mega-to-teensy-41>Microcontroller Upgrade: From Arduino Mega to Teensy 4.1<a hidden class=anchor aria-hidden=true href=#microcontroller-upgrade-from-arduino-mega-to-teensy-41>#</a></h2><p>During initial development, I used an <strong>Arduino Mega</strong> to read encoders, perform PID calculations, and communicate with ROS via serial. While the Mega worked well for prototyping, several limitations started to bottleneck development:</p><ul><li><strong>Limited clock speed (16 MHz)</strong> made it hard to handle high-frequency PID control and multi-tasking serial communications.</li><li><strong>Large physical footprint</strong> made internal mounting in the chassis more difficult.</li><li><strong>Lack of native USB high-speed and modern architecture</strong> led to sporadic delays under load.</li></ul><h3 id=the-decision-teensy-41>The Decision: Teensy 4.1<a hidden class=anchor aria-hidden=true href=#the-decision-teensy-41>#</a></h3><p>To solve these issues, I’ve decided to move forward with a <strong>Teensy 4.1</strong>:</p><ul><li><strong>600 MHz ARM Cortex-M7</strong> processor with 1 MB RAM gives us ample performance headroom.</li><li><strong>Compact form factor</strong> reduces space requirements in the electronics enclosure.</li><li><strong>Native USB High-Speed</strong> (480 Mbps) provides snappy ROS serial integration.</li><li><strong>Multiple hardware serial ports</strong> (up to 8!) simplifies wiring and expands options for future peripherals (e.g., GPS, IMU).</li></ul><p>The upgrade will also enable smoother encoder sampling, non-blocking communication, and support for real-time motor control tasks on a single MCU.</p><hr><h2 id=pid-tuning-challenges>PID Tuning Challenges<a hidden class=anchor aria-hidden=true href=#pid-tuning-challenges>#</a></h2><p>One of the more stubborn problems has been tuning the <strong>wheel speed PID controllers</strong>.</p><ul><li>With simulated data or slow commands, everything behaves predictably.</li><li>Under real load, slight mismatches in encoder readings or noisy sampling can cause aggressive oscillations or sluggish response.</li><li>Integral windup occasionally causes the rover to overshoot or lock into runaway output when reversing direction.</li></ul><p>Next steps include:</p><ul><li>Implementing <strong>anti-windup</strong> in the PID logic.</li><li>Adding <strong>low-pass filtering</strong> to the encoder velocity signal.</li><li>Dynamically scaling PID gains based on load or command profile.</li><li>Profiling CPU usage and ensuring sampling intervals remain consistent (especially after switching to Teensy).</li></ul><hr><h2 id=whats-next>What’s Next<a hidden class=anchor aria-hidden=true href=#whats-next>#</a></h2><ul><li>Finalize wiring for the Teensy 4.1 and update the firmware to support its serial and interrupt pin layout.</li><li>Connect ROS 2 controllers (like <code>diff_drive_controller</code>) and test real-world trajectory tracking.</li><li>Improve unit testing for the hardware interface and expand test coverage for safety-critical paths.</li><li>Explore publishing diagnostics like battery voltage, current draw, and motor temperature for system health monitoring.</li></ul><hr><p>Stay tuned for future posts as I bring the full stack online—from URDF and Gazebo simulation to autonomous waypoint navigation and mission execution.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://reeceholland.github.io/>Reece Holland</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>